<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chorale Architecture — Interactive State Machines</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace; background: #0d1117; color: #c9d1d9; overflow-x: hidden; }

  /* Nav */
  nav { position: fixed; top: 0; left: 0; right: 0; z-index: 100; background: #161b22; border-bottom: 1px solid #30363d; display: flex; align-items: center; gap: 4px; padding: 8px 16px; overflow-x: auto; }
  nav button { background: #21262d; color: #8b949e; border: 1px solid #30363d; padding: 6px 14px; border-radius: 6px; font-family: inherit; font-size: 12px; cursor: pointer; white-space: nowrap; transition: all 0.15s; }
  nav button:hover { background: #30363d; color: #c9d1d9; }
  nav button.active { background: #1f6feb; color: #fff; border-color: #1f6feb; }
  nav .title { color: #58a6ff; font-weight: 600; font-size: 14px; margin-right: 12px; }

  /* Main */
  main { padding: 60px 24px 24px; max-width: 1200px; margin: 0 auto; }

  /* Views */
  .view { display: none; }
  .view.active { display: block; }

  /* State machine canvas */
  .sm-container { position: relative; margin: 16px 0; }
  svg.sm { width: 100%; background: #0d1117; border: 1px solid #30363d; border-radius: 8px; }

  /* States */
  .state { cursor: pointer; transition: filter 0.15s; }
  .state:hover { filter: brightness(1.3); }
  .state rect, .state circle { transition: stroke-width 0.15s, stroke 0.15s; }
  .state.highlighted rect, .state.highlighted circle { stroke: #f0883e; stroke-width: 3; }
  .state.current rect, .state.current circle { stroke: #3fb950; stroke-width: 3; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.7; } }

  /* Transitions */
  .transition { cursor: pointer; }
  .transition line, .transition path { transition: stroke 0.15s, stroke-width 0.15s; }
  .transition:hover line, .transition:hover path { stroke: #f0883e; stroke-width: 2.5; }
  .transition.highlighted line, .transition.highlighted path { stroke: #f0883e; stroke-width: 2.5; }

  /* Info panel */
  .info-panel { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px; margin-top: 16px; min-height: 80px; }
  .info-panel h3 { color: #58a6ff; font-size: 14px; margin-bottom: 8px; }
  .info-panel p { font-size: 13px; line-height: 1.6; color: #8b949e; }
  .info-panel .highlight { color: #f0883e; }
  .info-panel code { background: #21262d; padding: 2px 6px; border-radius: 3px; font-size: 12px; color: #79c0ff; }
  .info-panel .tag { display: inline-block; background: #1f6feb22; color: #58a6ff; padding: 2px 8px; border-radius: 10px; font-size: 11px; margin: 2px 2px; }
  .info-panel .tag.event { background: #3fb95022; color: #3fb950; }
  .info-panel .tag.file { background: #f0883e22; color: #f0883e; }

  /* Simulation controls */
  .sim-controls { display: flex; gap: 8px; margin: 12px 0; flex-wrap: wrap; }
  .sim-controls button { background: #21262d; color: #c9d1d9; border: 1px solid #30363d; padding: 5px 12px; border-radius: 6px; font-family: inherit; font-size: 11px; cursor: pointer; transition: all 0.15s; }
  .sim-controls button:hover { background: #30363d; }
  .sim-controls button.fire { background: #1a7f37; border-color: #238636; }
  .sim-controls button.fire:hover { background: #238636; }
  .sim-controls button.reset { background: #6e2d2d; border-color: #da3633; }
  .sim-controls button.reset:hover { background: #8b3535; }

  /* Overview */
  .overview-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; margin-top: 16px; }
  .overview-card { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px; cursor: pointer; transition: all 0.15s; }
  .overview-card:hover { border-color: #58a6ff; transform: translateY(-2px); }
  .overview-card h3 { color: #58a6ff; font-size: 14px; margin-bottom: 6px; }
  .overview-card p { color: #8b949e; font-size: 12px; line-height: 1.5; }
  .overview-card .states-preview { margin-top: 8px; display: flex; gap: 4px; flex-wrap: wrap; }
  .overview-card .sp { background: #21262d; color: #79c0ff; padding: 2px 8px; border-radius: 10px; font-size: 10px; }

  /* Data flow */
  .flow-step { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px 16px; margin: 8px 0; display: flex; align-items: flex-start; gap: 12px; cursor: pointer; transition: all 0.15s; }
  .flow-step:hover { border-color: #58a6ff; }
  .flow-step.active-step { border-color: #3fb950; background: #0d1117; }
  .flow-step .step-num { background: #1f6feb; color: #fff; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 11px; flex-shrink: 0; }
  .flow-step.active-step .step-num { background: #3fb950; }
  .flow-step .step-content h4 { color: #c9d1d9; font-size: 13px; }
  .flow-step .step-content p { color: #8b949e; font-size: 12px; margin-top: 2px; }

  /* Section headers */
  .section-header { color: #c9d1d9; font-size: 18px; margin: 20px 0 8px; font-weight: 600; }
  .section-sub { color: #8b949e; font-size: 13px; margin-bottom: 16px; }

  /* Arrow markers */
  .arrow-head { fill: #484f58; }
  .arrow-head-highlight { fill: #f0883e; }
</style>
</head>
<body>

<nav>
  <span class="title">Chorale</span>
  <button class="active" data-view="overview">Overview</button>
  <button data-view="chat-lifecycle">Chat Lifecycle</button>
  <button data-view="harness">Harness Tracker</button>
  <button data-view="pty">PTY Lifecycle</button>
  <button data-view="startup">Startup Flow</button>
  <button data-view="events">Event Streams</button>
  <button data-view="data-flow">Data Flow</button>
</nav>

<main>

<!-- ==================== OVERVIEW ==================== -->
<div class="view active" id="view-overview">
  <h2 class="section-header">Architecture Overview</h2>
  <p class="section-sub">Click any card to explore that state machine interactively.</p>
  <div class="overview-grid">
    <div class="overview-card" data-nav="chat-lifecycle">
      <h3>Chat Lifecycle</h3>
      <p>How chats are created, go active/idle, and terminate. Managed by ChatRegistry on the server.</p>
      <div class="states-preview">
        <span class="sp">active</span><span class="sp">idle</span><span class="sp">done</span><span class="sp">error</span>
      </div>
    </div>
    <div class="overview-card" data-nav="harness">
      <h3>Harness Tracker</h3>
      <p>Per-chat AI agent status: thinking, writing, tool use, waiting. Fed by CLI hooks + output parser.</p>
      <div class="states-preview">
        <span class="sp">idle</span><span class="sp">thinking</span><span class="sp">writing</span><span class="sp">tool-use</span><span class="sp">waiting</span><span class="sp">done</span><span class="sp">error</span>
      </div>
    </div>
    <div class="overview-card" data-nav="pty">
      <h3>PTY Lifecycle</h3>
      <p>Pseudo-terminal spawn, output buffering (200KB cap), seed on resume, and cleanup.</p>
      <div class="states-preview">
        <span class="sp">spawn</span><span class="sp">running</span><span class="sp">buffering</span><span class="sp">exited</span>
      </div>
    </div>
    <div class="overview-card" data-nav="startup">
      <h3>Startup Flow</h3>
      <p>Server boot → port allocation → renderer connects via WebSocket → Tauri native overrides.</p>
      <div class="states-preview">
        <span class="sp">server</span><span class="sp">ws-connect</span><span class="sp">hydrate</span><span class="sp">ready</span>
      </div>
    </div>
    <div class="overview-card" data-nav="events">
      <h3>Event Streams</h3>
      <p>Three event families: Terminal, Harness, CLI. All feed lifecycle emitter, logged to JSONL.</p>
      <div class="states-preview">
        <span class="sp">terminal</span><span class="sp">harness</span><span class="sp">cli</span>
      </div>
    </div>
    <div class="overview-card" data-nav="data-flow">
      <h3>Data Flow</h3>
      <p>PTY output → parser → tracker → lifecycle → WebSocket push → Zustand → React render.</p>
      <div class="states-preview">
        <span class="sp">server</span><span class="sp">ws</span><span class="sp">store</span><span class="sp">ui</span>
      </div>
    </div>
  </div>
</div>

<!-- ==================== CHAT LIFECYCLE ==================== -->
<div class="view" id="view-chat-lifecycle">
  <h2 class="section-header">Chat Lifecycle State Machine</h2>
  <p class="section-sub">Click states to inspect. Use simulation buttons to step through transitions.</p>

  <div class="sim-controls" id="chat-sim">
    <button class="fire" onclick="fireChatEvent('create')">createChat()</button>
    <button class="fire" onclick="fireChatEvent('output')">PTY output</button>
    <button class="fire" onclick="fireChatEvent('idle')">3s no output</button>
    <button class="fire" onclick="fireChatEvent('exit-ok')">PTY exit(0)</button>
    <button class="fire" onclick="fireChatEvent('exit-err')">PTY exit(1)</button>
    <button class="fire" onclick="fireChatEvent('resume')">resumeChat()</button>
    <button class="fire" onclick="fireChatEvent('delete')">deleteChat()</button>
    <button class="reset" onclick="resetChatSim()">Reset</button>
  </div>

  <div class="sm-container">
    <svg class="sm" viewBox="0 0 800 380" id="chat-svg">
      <defs>
        <marker id="ah1" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" class="arrow-head"/></marker>
        <marker id="ah1h" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" class="arrow-head-highlight"/></marker>
      </defs>

      <!-- States -->
      <g class="state" data-state="none" transform="translate(60,170)">
        <circle cx="0" cy="0" r="20" fill="#21262d" stroke="#484f58" stroke-width="2"/>
        <text x="0" y="4" text-anchor="middle" fill="#8b949e" font-size="10">start</text>
      </g>

      <g class="state" data-state="active" transform="translate(240,170)">
        <rect x="-55" y="-25" width="110" height="50" rx="8" fill="#0d4429" stroke="#3fb950" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#3fb950" font-size="13" font-weight="600">active</text>
      </g>

      <g class="state" data-state="idle" transform="translate(450,170)">
        <rect x="-45" y="-25" width="90" height="50" rx="8" fill="#2d1f00" stroke="#d29922" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#d29922" font-size="13" font-weight="600">idle</text>
      </g>

      <g class="state" data-state="done" transform="translate(660,100)">
        <rect x="-45" y="-25" width="90" height="50" rx="8" fill="#1c2541" stroke="#58a6ff" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#58a6ff" font-size="13" font-weight="600">done</text>
      </g>

      <g class="state" data-state="error" transform="translate(660,240)">
        <rect x="-45" y="-25" width="90" height="50" rx="8" fill="#3d1214" stroke="#da3633" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#da3633" font-size="13" font-weight="600">error</text>
      </g>

      <g class="state" data-state="deleted" transform="translate(450,320)">
        <rect x="-50" y="-20" width="100" height="40" rx="8" fill="#21262d" stroke="#484f58" stroke-width="2" stroke-dasharray="4"/>
        <text x="0" y="5" text-anchor="middle" fill="#484f58" font-size="12">(deleted)</text>
      </g>

      <!-- Transitions -->
      <g class="transition" data-from="none" data-to="active" data-label="createChat()">
        <line x1="80" y1="170" x2="180" y2="170" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah1)"/>
        <text x="130" y="162" text-anchor="middle" fill="#8b949e" font-size="9">createChat()</text>
      </g>

      <g class="transition" data-from="active" data-to="idle" data-label="3s timeout">
        <line x1="295" y1="155" x2="400" y2="155" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah1)"/>
        <text x="348" y="148" text-anchor="middle" fill="#8b949e" font-size="9">3s no output</text>
      </g>

      <g class="transition" data-from="idle" data-to="active" data-label="PTY output">
        <line x1="400" y1="185" x2="295" y2="185" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah1)"/>
        <text x="348" y="200" text-anchor="middle" fill="#8b949e" font-size="9">PTY output</text>
      </g>

      <g class="transition" data-from="active" data-to="done" data-label="exit(0)">
        <line x1="290" y1="148" x2="612" y2="102" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah1)"/>
        <text x="440" y="112" text-anchor="middle" fill="#8b949e" font-size="9">exit(0)</text>
      </g>

      <g class="transition" data-from="idle" data-to="done" data-label="exit(0)">
        <line x1="495" y1="155" x2="612" y2="112" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah1)"/>
        <text x="564" y="122" text-anchor="middle" fill="#8b949e" font-size="9">exit(0)</text>
      </g>

      <g class="transition" data-from="active" data-to="error" data-label="exit(≠0)">
        <line x1="290" y1="192" x2="612" y2="238" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah1)"/>
        <text x="440" y="230" text-anchor="middle" fill="#8b949e" font-size="9">exit(≠0)</text>
      </g>

      <g class="transition" data-from="idle" data-to="error" data-label="exit(≠0)">
        <line x1="495" y1="185" x2="612" y2="228" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah1)"/>
        <text x="564" y="218" text-anchor="middle" fill="#8b949e" font-size="9">exit(≠0)</text>
      </g>

      <g class="transition" data-from="done" data-to="active" data-label="resumeChat()">
        <path d="M 615,88 Q 400,30 295,148" fill="none" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah1)"/>
        <text x="430" y="52" text-anchor="middle" fill="#8b949e" font-size="9">resumeChat()</text>
      </g>

      <g class="transition" data-from="active" data-to="deleted" data-label="deleteChat()">
        <line x1="240" y1="195" x2="405" y2="305" stroke="#484f58" stroke-width="1.5" stroke-dasharray="4" marker-end="url(#ah1)"/>
        <text x="300" y="265" text-anchor="middle" fill="#8b949e" font-size="9">deleteChat()</text>
      </g>

      <g class="transition" data-from="idle" data-to="deleted" data-label="deleteChat()">
        <line x1="450" y1="195" x2="450" y2="296" stroke="#484f58" stroke-width="1.5" stroke-dasharray="4" marker-end="url(#ah1)"/>
        <text x="470" y="260" text-anchor="middle" fill="#8b949e" font-size="9">delete</text>
      </g>
    </svg>
  </div>

  <div class="info-panel" id="chat-info">
    <h3>Chat Lifecycle</h3>
    <p>Click a state or transition, or use the simulation buttons above to walk through the state machine. Managed by <code>ChatRegistry</code> in <span class="tag file">packages/server/src/chat-registry.ts</span></p>
  </div>
</div>

<!-- ==================== HARNESS TRACKER ==================== -->
<div class="view" id="view-harness">
  <h2 class="section-header">Harness Tracker State Machine</h2>
  <p class="section-sub">Tracks per-chat AI agent activity: thinking, writing code, using tools, waiting for input.</p>

  <div class="sim-controls" id="harness-sim">
    <button class="fire" onclick="fireHarnessEvent('thinking')">thinking</button>
    <button class="fire" onclick="fireHarnessEvent('writing')">writing</button>
    <button class="fire" onclick="fireHarnessEvent('tool-start')">tool:start</button>
    <button class="fire" onclick="fireHarnessEvent('tool-end')">tool:end</button>
    <button class="fire" onclick="fireHarnessEvent('waiting')">waiting</button>
    <button class="fire" onclick="fireHarnessEvent('stop')">stop</button>
    <button class="reset" onclick="resetHarnessSim()">Reset</button>
  </div>

  <div class="sm-container">
    <svg class="sm" viewBox="0 0 800 450" id="harness-svg">
      <defs>
        <marker id="ah2" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" class="arrow-head"/></marker>
      </defs>

      <!-- States -->
      <g class="state" data-state="h-idle" transform="translate(110,220)">
        <rect x="-45" y="-25" width="90" height="50" rx="8" fill="#21262d" stroke="#484f58" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#8b949e" font-size="13" font-weight="600">idle</text>
      </g>

      <g class="state" data-state="h-thinking" transform="translate(300,100)">
        <rect x="-55" y="-25" width="110" height="50" rx="8" fill="#1c1c3a" stroke="#a371f7" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#a371f7" font-size="13" font-weight="600">thinking</text>
      </g>

      <g class="state" data-state="h-writing" transform="translate(300,220)">
        <rect x="-50" y="-25" width="100" height="50" rx="8" fill="#0d4429" stroke="#3fb950" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#3fb950" font-size="13" font-weight="600">writing</text>
      </g>

      <g class="state" data-state="h-tool-use" transform="translate(300,340)">
        <rect x="-50" y="-25" width="100" height="50" rx="8" fill="#2d1f00" stroke="#d29922" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#d29922" font-size="13" font-weight="600">tool-use</text>
      </g>

      <g class="state" data-state="h-waiting" transform="translate(530,220)">
        <rect x="-50" y="-25" width="100" height="50" rx="8" fill="#1c2541" stroke="#58a6ff" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#58a6ff" font-size="13" font-weight="600">waiting</text>
      </g>

      <g class="state" data-state="h-done" transform="translate(710,160)">
        <rect x="-40" y="-25" width="80" height="50" rx="8" fill="#1c2541" stroke="#58a6ff" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#58a6ff" font-size="13" font-weight="600">done</text>
      </g>

      <g class="state" data-state="h-error" transform="translate(710,280)">
        <rect x="-40" y="-25" width="80" height="50" rx="8" fill="#3d1214" stroke="#da3633" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#da3633" font-size="13" font-weight="600">error</text>
      </g>

      <!-- Transitions -->
      <g class="transition" data-from="h-idle" data-to="h-thinking">
        <path d="M 145,200 L 250,112" fill="none" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="185" y="145" fill="#8b949e" font-size="9">thinking</text>
      </g>
      <g class="transition" data-from="h-idle" data-to="h-writing">
        <line x1="155" y1="220" x2="245" y2="220" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="200" y="212" text-anchor="middle" fill="#8b949e" font-size="9">writing</text>
      </g>
      <g class="transition" data-from="h-idle" data-to="h-tool-use">
        <path d="M 145,240 L 255,328" fill="none" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="180" y="298" fill="#8b949e" font-size="9">tool:start</text>
      </g>

      <g class="transition" data-from="h-thinking" data-to="h-writing">
        <line x1="300" y1="125" x2="300" y2="190" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="318" y="162" fill="#8b949e" font-size="9">writing</text>
      </g>
      <g class="transition" data-from="h-thinking" data-to="h-tool-use">
        <path d="M 280,125 L 270,310" fill="none" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="255" y="225" fill="#8b949e" font-size="9">tool:start</text>
      </g>

      <g class="transition" data-from="h-writing" data-to="h-tool-use">
        <line x1="300" y1="245" x2="300" y2="310" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="318" y="282" fill="#8b949e" font-size="9">tool:start</text>
      </g>

      <g class="transition" data-from="h-tool-use" data-to="h-writing">
        <path d="M 340,318 Q 370,280 340,248" fill="none" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="370" y="282" fill="#8b949e" font-size="9">tool:end</text>
      </g>

      <g class="transition" data-from="h-writing" data-to="h-waiting">
        <line x1="350" y1="220" x2="475" y2="220" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="412" y="212" text-anchor="middle" fill="#8b949e" font-size="9">waiting</text>
      </g>

      <g class="transition" data-from="h-waiting" data-to="h-done">
        <line x1="575" y1="205" x2="668" y2="172" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah2)"/>
        <text x="622" y="180" fill="#8b949e" font-size="9">stop</text>
      </g>

      <!-- Any → done/error (dashed) -->
      <g class="transition" data-from="any" data-to="h-done">
        <path d="M 710,135 Q 740,80 740,50" fill="none" stroke="#484f58" stroke-width="1" stroke-dasharray="4"/>
        <text x="748" y="55" fill="#8b949e" font-size="8">stop (any)</text>
      </g>
      <g class="transition" data-from="any" data-to="h-error">
        <path d="M 710,305 Q 740,360 740,385" fill="none" stroke="#484f58" stroke-width="1" stroke-dasharray="4"/>
        <text x="748" y="390" fill="#8b949e" font-size="8">markError (any)</text>
      </g>
    </svg>
  </div>

  <div class="info-panel" id="harness-info">
    <h3>Harness Tracker</h3>
    <p>Tracks per-chat AI status. Fed by two sources: <span class="tag">CLI hooks</span> (Claude only, structured) and <span class="tag">Output parser</span> (all CLIs, heuristic). File: <span class="tag file">packages/server/src/harness-tracker.ts</span></p>
  </div>
</div>

<!-- ==================== PTY LIFECYCLE ==================== -->
<div class="view" id="view-pty">
  <h2 class="section-header">PTY Lifecycle</h2>
  <p class="section-sub">Pseudo-terminal management with 200KB output buffer, seed-on-resume, and callback cleanup.</p>

  <div class="sim-controls">
    <button class="fire" onclick="firePtyEvent('create')">create()</button>
    <button class="fire" onclick="firePtyEvent('output')">data output</button>
    <button class="fire" onclick="firePtyEvent('overflow')">buffer overflow</button>
    <button class="fire" onclick="firePtyEvent('write')">write(input)</button>
    <button class="fire" onclick="firePtyEvent('exit')">exit</button>
    <button class="fire" onclick="firePtyEvent('seed')">seedBuffer()</button>
    <button class="fire" onclick="firePtyEvent('destroy')">destroy()</button>
    <button class="reset" onclick="resetPtySim()">Reset</button>
  </div>

  <div class="sm-container">
    <svg class="sm" viewBox="0 0 800 320" id="pty-svg">
      <defs>
        <marker id="ah3" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" class="arrow-head"/></marker>
      </defs>

      <g class="state" data-state="p-none" transform="translate(70,160)">
        <circle cx="0" cy="0" r="20" fill="#21262d" stroke="#484f58" stroke-width="2"/>
        <text x="0" y="4" text-anchor="middle" fill="#8b949e" font-size="10">init</text>
      </g>

      <g class="state" data-state="p-spawned" transform="translate(220,160)">
        <rect x="-55" y="-25" width="110" height="50" rx="8" fill="#0d4429" stroke="#3fb950" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#3fb950" font-size="13" font-weight="600">spawned</text>
      </g>

      <g class="state" data-state="p-running" transform="translate(420,160)">
        <rect x="-50" y="-25" width="100" height="50" rx="8" fill="#0d4429" stroke="#3fb950" stroke-width="2"/>
        <text x="0" y="0" text-anchor="middle" fill="#3fb950" font-size="13" font-weight="600">running</text>
        <text x="0" y="15" text-anchor="middle" fill="#3fb950" font-size="9">buf: 0KB</text>
      </g>

      <g class="state" data-state="p-overflow" transform="translate(420,60)">
        <rect x="-55" y="-20" width="110" height="40" rx="8" fill="#2d1f00" stroke="#d29922" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#d29922" font-size="11">buf &gt; 200KB</text>
      </g>

      <g class="state" data-state="p-exited" transform="translate(630,160)">
        <rect x="-45" y="-25" width="90" height="50" rx="8" fill="#1c2541" stroke="#58a6ff" stroke-width="2"/>
        <text x="0" y="5" text-anchor="middle" fill="#58a6ff" font-size="13" font-weight="600">exited</text>
      </g>

      <g class="state" data-state="p-destroyed" transform="translate(630,280)">
        <rect x="-50" y="-20" width="100" height="40" rx="8" fill="#21262d" stroke="#484f58" stroke-width="2" stroke-dasharray="4"/>
        <text x="0" y="5" text-anchor="middle" fill="#484f58" font-size="12">(destroyed)</text>
      </g>

      <!-- Transitions -->
      <g class="transition"><line x1="90" y1="160" x2="160" y2="160" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah3)"/>
        <text x="125" y="152" text-anchor="middle" fill="#8b949e" font-size="9">create()</text></g>

      <g class="transition"><line x1="275" y1="160" x2="365" y2="160" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah3)"/>
        <text x="320" y="152" text-anchor="middle" fill="#8b949e" font-size="9">data</text></g>

      <g class="transition"><path d="M 420,135 L 420,84" fill="none" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah3)"/>
        <text x="440" y="108" fill="#8b949e" font-size="9">&gt;200KB</text></g>

      <g class="transition"><path d="M 395,68 Q 350,50 395,135" fill="none" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah3)"/>
        <text x="340" y="96" fill="#8b949e" font-size="9">slice→100KB</text></g>

      <g class="transition"><line x1="470" y1="160" x2="582" y2="160" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah3)"/>
        <text x="526" y="152" text-anchor="middle" fill="#8b949e" font-size="9">exit</text></g>

      <g class="transition"><line x1="420" y1="185" x2="585" y2="268" stroke="#484f58" stroke-width="1.5" stroke-dasharray="4" marker-end="url(#ah3)"/>
        <text x="490" y="240" fill="#8b949e" font-size="9">destroy()</text></g>

      <!-- seed loop -->
      <g class="transition"><path d="M 220,135 Q 220,80 320,80 Q 370,80 370,135" fill="none" stroke="#484f58" stroke-width="1.5" marker-end="url(#ah3)"/>
        <text x="295" y="72" text-anchor="middle" fill="#8b949e" font-size="9">seedBuffer()</text></g>
    </svg>
  </div>

  <div class="info-panel" id="pty-info">
    <h3>PTY Manager</h3>
    <p>Manages node-pty processes. Output buffer capped at <code>200KB</code>, slides to <code>100KB</code> on overflow. On resume, <code>seedBuffer()</code> prepends saved terminal content. File: <span class="tag file">packages/server/src/pty-manager.ts</span></p>
  </div>
</div>

<!-- ==================== STARTUP FLOW ==================== -->
<div class="view" id="view-startup">
  <h2 class="section-header">Startup Flow</h2>
  <p class="section-sub">Click each step to see details. Server boots first, then renderer connects.</p>

  <h3 style="color:#58a6ff; font-size:13px; margin:16px 0 8px;">Server Startup <span class="tag file">packages/server/src/main.ts</span></h3>
  <div id="startup-server-steps">
    <div class="flow-step" data-detail="Read settings from chorale-state.json: llmCommand, maxChatDepth, projectRoots, theme mode." onclick="activateStep(this)">
      <div class="step-num">1</div>
      <div class="step-content"><h4>Read Settings</h4><p>Load persisted config from chorale-state.json</p></div>
    </div>
    <div class="flow-step" data-detail="WrapperManager isolates CLI environments. ThemeManager tracks dark/light/system mode + resolved value." onclick="activateStep(this)">
      <div class="step-num">2</div>
      <div class="step-content"><h4>Create Managers</h4><p>WrapperManager, ThemeManager, PtyManager</p></div>
    </div>
    <div class="flow-step" data-detail="ChatRegistry.loadFromDisk() reads all ~/.chorale/chats/*/metadata.json. All chats marked 'done' (no active PTY yet). reconcilePtys() verifies integrity." onclick="activateStep(this)">
      <div class="step-num">3</div>
      <div class="step-content"><h4>ChatRegistry.loadFromDisk()</h4><p>Load chat metadata, mark all done, reconcile orphans</p></div>
    </div>
    <div class="flow-step" data-detail="TaskScheduler.loadAndStart() loads schedules.json. Starts cron/timeout jobs for enabled schedules. Cleans any stuck 'running' → 'failed'." onclick="activateStep(this)">
      <div class="step-num">4</div>
      <div class="step-content"><h4>TaskScheduler.loadAndStart()</h4><p>Load schedules, start cron jobs, clean stuck runs</p></div>
    </div>
    <div class="flow-step" data-detail="ApiServer.start(port) binds HTTP REST + WebSocket on a random localhost port. Writes port to stdout as PORT={port} for parent (Tauri sidecar) to read." onclick="activateStep(this)">
      <div class="step-num">5</div>
      <div class="step-content"><h4>ApiServer.start(port)</h4><p>HTTP + WebSocket on random port, output PORT={n}</p></div>
    </div>
  </div>

  <h3 style="color:#58a6ff; font-size:13px; margin:24px 0 8px;">Renderer Connection <span class="tag file">tauri/src/main.tsx</span></h3>
  <div id="startup-renderer-steps">
    <div class="flow-step" data-detail="Tauri invoke('get_server_port') reads the port from the sidecar process stdout. Browser reads from URL query param." onclick="activateStep(this)">
      <div class="step-num">6</div>
      <div class="step-content"><h4>Get Server Port</h4><p>Tauri: invoke(), Browser: URL param</p></div>
    </div>
    <div class="flow-step" data-detail="createWebSocketAdapter(serverUrl) from @chorale/platform. Establishes ws://localhost:{port}/ws connection. Bidirectional ServerMessage/ClientMessage protocol." onclick="activateStep(this)">
      <div class="step-num">7</div>
      <div class="step-content"><h4>WebSocket Connect</h4><p>createWebSocketAdapter → ws://localhost:{port}/ws</p></div>
    </div>
    <div class="flow-step" data-detail="Tauri overrides: selectDirectory → @tauri-apps/plugin-dialog, openExternal → plugin-opener, theme.setMode → POST /api/theme/mode, theme.onResolvedChanged → system theme listener." onclick="activateStep(this)">
      <div class="step-num">8</div>
      <div class="step-content"><h4>Native Overrides</h4><p>selectDirectory, openExternal, theme listeners</p></div>
    </div>
    <div class="flow-step" data-detail="initApp(adapter) creates the Zustand store, hydrates persisted state from disk. PlatformProvider wraps the React tree. window.__store exposed in dev." onclick="activateStep(this)">
      <div class="step-num">9</div>
      <div class="step-content"><h4>Init App + Hydrate</h4><p>Create Zustand store, hydrate from disk, render React</p></div>
    </div>
  </div>

  <div class="info-panel" id="startup-info">
    <h3>Startup</h3>
    <p>Click a step above to see details about that phase of startup.</p>
  </div>
</div>

<!-- ==================== EVENT STREAMS ==================== -->
<div class="view" id="view-events">
  <h2 class="section-header">Lifecycle Event Streams</h2>
  <p class="section-sub">Three event families feed into a single lifecycle emitter. Subscribe with <code>lifecycle.on('*', handler)</code> or prefix patterns like <code>'harness:*'</code>.</p>

  <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); gap:12px; margin-top:16px;">
    <div class="info-panel" style="cursor:pointer;" onclick="showEventFamily('terminal')">
      <h3 style="color:#3fb950;">Terminal Events</h3>
      <p>
        <span class="tag event">chat:created</span>
        <span class="tag event">chat:resumed</span>
        <span class="tag event">chat:deleted</span>
        <span class="tag event">chat:status</span>
        <span class="tag event">pty:spawned</span>
        <span class="tag event">pty:exit</span>
        <span class="tag event">pty:prompt-delivered</span>
        <span class="tag event">pty:prompt-failed</span>
        <span class="tag event">schedule:triggered</span>
        <span class="tag event">schedule:completed</span>
      </p>
      <p style="margin-top:8px;">Emitted by <code>ChatRegistry</code> and <code>PtyManager</code></p>
    </div>
    <div class="info-panel" style="cursor:pointer;" onclick="showEventFamily('harness')">
      <h3 style="color:#a371f7;">Harness Events</h3>
      <p>
        <span class="tag event">harness:tool:start</span>
        <span class="tag event">harness:tool:end</span>
        <span class="tag event">harness:stop</span>
        <span class="tag event">harness:thinking</span>
        <span class="tag event">harness:writing</span>
        <span class="tag event">harness:waiting</span>
        <span class="tag event">harness:status</span>
      </p>
      <p style="margin-top:8px;">From CLI hooks + <code>HarnessParser</code> output parsing</p>
    </div>
    <div class="info-panel" style="cursor:pointer;" onclick="showEventFamily('cli')">
      <h3 style="color:#d29922;">CLI Events</h3>
      <p>
        <span class="tag event">cli:dispatch</span>
        <span class="tag event">cli:status</span>
        <span class="tag event">cli:schedule</span>
        <span class="tag event">cli:report</span>
        <span class="tag event">cli:project</span>
        <span class="tag event">cli:hook</span>
      </p>
      <p style="margin-top:8px;">Emitted by <code>ApiServer</code> on every agent request</p>
    </div>
  </div>

  <div class="info-panel" id="events-info" style="margin-top:16px;">
    <h3>Event Flow</h3>
    <p>All events logged to <code>~/.chorale/logs/chorale.jsonl</code> (JSON lines, rotated at 5MB). File: <span class="tag file">packages/server/src/lifecycle.ts</span> and <span class="tag file">packages/api-types/src/events.ts</span></p>
  </div>
</div>

<!-- ==================== DATA FLOW ==================== -->
<div class="view" id="view-data-flow">
  <h2 class="section-header">Data Flow Pipeline</h2>
  <p class="section-sub">How PTY output becomes a React render. Click each stage.</p>

  <div id="data-flow-steps">
    <div class="flow-step" data-detail="node-pty spawns a shell process. Raw terminal output (ANSI escape codes, text) flows through the onData callback into PtyManager." onclick="activateStep(this)">
      <div class="step-num">1</div>
      <div class="step-content"><h4>PTY Output</h4><p>node-pty process emits raw terminal data</p></div>
    </div>
    <div class="flow-step" data-detail="PtyManager appends to 200KB output buffer (slides to 100KB on overflow). Fires onOutput callbacks to all subscribers. Also fires onActivity for idle detection." onclick="activateStep(this)">
      <div class="step-num">2</div>
      <div class="step-content"><h4>PtyManager Buffer</h4><p>Append to 200KB circular buffer, fire callbacks</p></div>
    </div>
    <div class="flow-step" data-detail="HarnessParser.feed() receives raw output. ClaudeOutputParser detects tool boxes (╭─ ╰─), thinking spinners, cost summary, prompt. GenericOutputParser uses idle/burst heuristics. Returns HarnessEvent[]." onclick="activateStep(this)">
      <div class="step-num">3</div>
      <div class="step-content"><h4>HarnessParser</h4><p>Parse output → detect tools, thinking, waiting</p></div>
    </div>
    <div class="flow-step" data-detail="Each HarnessEvent is emitted to the lifecycle emitter. HarnessTracker.handleEvent() updates per-chat state (status, currentTool, toolsUsed). On state change, emits harness:status." onclick="activateStep(this)">
      <div class="step-num">4</div>
      <div class="step-content"><h4>Lifecycle + HarnessTracker</h4><p>Events → state machine → harness:status emission</p></div>
    </div>
    <div class="flow-step" data-detail="ChatRegistry detects status changes (active/idle/done/error). Debounced persist (500ms) to chat-registry.json. Calls pushToRenderer() which serializes all ChatRecords and broadcasts via WebSocket." onclick="activateStep(this)">
      <div class="step-num">5</div>
      <div class="step-content"><h4>ChatRegistry Push</h4><p>State change → debounced persist → WebSocket broadcast</p></div>
    </div>
    <div class="flow-step" data-detail="WebSocket message received in renderer. Zustand store updated with new chat state. Granular selectors (from perf fix) ensure only affected components re-render — not the entire tree." onclick="activateStep(this)">
      <div class="step-num">6</div>
      <div class="step-content"><h4>Zustand Store</h4><p>WS push → update store → granular selectors</p></div>
    </div>
    <div class="flow-step" data-detail="React components subscribed via useAppStore(s => s.specificField) re-render only when their slice changes. Terminal uses xterm.js write() directly from PTY output stream (not through React)." onclick="activateStep(this)">
      <div class="step-num">7</div>
      <div class="step-content"><h4>React Render</h4><p>Selective re-render via granular Zustand selectors</p></div>
    </div>
  </div>

  <div class="info-panel" id="data-flow-info">
    <h3>Data Flow</h3>
    <p>Click a stage above to see details. Terminal output goes directly to xterm.js (bypasses React). Only metadata (chat status, harness state) flows through React.</p>
  </div>
</div>

</main>

<script>
// ========== Navigation ==========
const navButtons = document.querySelectorAll('nav button');
const views = document.querySelectorAll('.view');

function showView(id) {
  views.forEach(v => v.classList.remove('active'));
  navButtons.forEach(b => b.classList.remove('active'));
  const view = document.getElementById('view-' + id);
  if (view) view.classList.add('active');
  const btn = document.querySelector(`nav button[data-view="${id}"]`);
  if (btn) btn.classList.add('active');
}

navButtons.forEach(btn => btn.addEventListener('click', () => showView(btn.dataset.view)));
document.querySelectorAll('.overview-card').forEach(card => {
  card.addEventListener('click', () => showView(card.dataset.nav));
});

// ========== State click info ==========
const stateInfo = {
  'none': { title: 'Start', desc: 'No chat exists yet. A new chat is created via <code>createChat(opts)</code> which allocates a directory, spawns a PTY, and transitions to <strong>active</strong>.', events: [] },
  'active': { title: 'Active', desc: 'Chat has a live PTY with recent output. An idle timer resets on every PTY data event. If no output for 3 seconds (<code>IDLE_THRESHOLD</code>), transitions to <strong>idle</strong>.', events: ['chat:status (→active)', 'pty:spawned'] },
  'idle': { title: 'Idle', desc: 'PTY is alive but no output for 3+ seconds. The agent may be thinking or waiting for input. Any new PTY output transitions back to <strong>active</strong>.', events: ['chat:status (→idle)'] },
  'done': { title: 'Done', desc: 'PTY exited with code 0. Terminal buffer saved to <code>{chatDir}/terminal-buffer</code>. Can be resumed with <code>resumeChat()</code> which spawns a fresh PTY with CLI resume flags.', events: ['pty:exit (code 0)', 'chat:status (→done)'] },
  'error': { title: 'Error', desc: 'PTY exited with non-zero code. Terminal buffer saved. Chat can still be resumed — if resume fails quickly (&lt;5s), retries without <code>--continue</code> flag.', events: ['pty:exit (code ≠0)', 'chat:status (→error)'] },
  'deleted': { title: 'Deleted', desc: 'Chat removed via <code>deleteChat()</code>. PTY destroyed, working directory removed, record deleted from registry.', events: ['chat:deleted'] },

  'h-idle': { title: 'Idle (Harness)', desc: 'Initial state. No AI activity detected yet. Waiting for the agent to start working.', events: [] },
  'h-thinking': { title: 'Thinking', desc: 'Agent is reasoning/planning. Detected by: Claude spinner characters (⠋⠙⠹…) or "Thinking" text in output.', events: ['harness:thinking'] },
  'h-writing': { title: 'Writing', desc: 'Agent is producing output (code, text). Entered after thinking or after a tool completes (<code>tool:end</code>).', events: ['harness:writing'] },
  'h-tool-use': { title: 'Tool Use', desc: 'Agent is executing a tool. Detected by Claude tool box (╭─ toolname) or CLI hook (<code>PreToolUse</code>). <code>toolsUsed</code> counter increments.', events: ['harness:tool:start'] },
  'h-waiting': { title: 'Waiting', desc: 'Agent is waiting for user input. Detected by prompt pattern ([❯>$] at end of line).', events: ['harness:waiting'] },
  'h-done': { title: 'Done (Harness)', desc: 'Agent session complete. Triggered by <code>harness:stop</code> event (cost summary detected) or <code>markDone()</code>.', events: ['harness:stop'] },
  'h-error': { title: 'Error (Harness)', desc: 'Agent encountered an error. Set via <code>markError()</code> when PTY exits with non-zero code.', events: ['harness:status (error)'] },

  'p-none': { title: 'Init', desc: 'No PTY exists. <code>PtyManager.create()</code> will spawn a node-pty process.', events: [] },
  'p-spawned': { title: 'Spawned', desc: 'PTY process created via <code>node-pty</code>. Callbacks registered: onData, onExit. Initial command written if provided. Unique ID assigned (<code>pty-{n}</code>).', events: ['pty:spawned'] },
  'p-running': { title: 'Running', desc: 'PTY is receiving output. Data appended to 200KB circular buffer. Callbacks fired: onOutput, onActivity, onTitle (OSC sequences).', events: [] },
  'p-overflow': { title: 'Buffer Overflow', desc: 'Output buffer exceeded 200KB. Automatically sliced to last 100KB to prevent memory bloat. This is transparent to consumers.', events: [] },
  'p-exited': { title: 'Exited', desc: 'PTY process terminated. Exit code passed to all onExit callbacks. Instance removed from PtyManager map. Terminal buffer available for persistence.', events: ['pty:exit'] },
  'p-destroyed': { title: 'Destroyed', desc: 'PTY forcefully killed via <code>destroy()</code>. Process terminated, instance removed from map. Used by <code>deleteChat()</code>.', events: [] },
};

document.querySelectorAll('.state').forEach(el => {
  el.addEventListener('click', () => {
    const key = el.dataset.state;
    const info = stateInfo[key];
    if (!info) return;
    // find the parent view's info panel
    const view = el.closest('.view');
    const panel = view.querySelector('.info-panel');
    if (!panel) return;
    let eventsHtml = info.events.length
      ? '<br>' + info.events.map(e => `<span class="tag event">${e}</span>`).join(' ')
      : '';
    panel.innerHTML = `<h3>${info.title}</h3><p>${info.desc}${eventsHtml}</p>`;

    // highlight
    view.querySelectorAll('.state').forEach(s => s.classList.remove('highlighted'));
    el.classList.add('highlighted');
  });
});

// ========== Chat Simulation ==========
let chatState = 'none';

function setChatState(state) {
  chatState = state;
  const svg = document.getElementById('chat-svg');
  svg.querySelectorAll('.state').forEach(s => {
    s.classList.remove('current');
    if (s.dataset.state === state) s.classList.add('current');
  });
  const info = stateInfo[state];
  if (info) {
    const panel = document.getElementById('chat-info');
    let eventsHtml = info.events.length
      ? '<br>' + info.events.map(e => `<span class="tag event">${e}</span>`).join(' ')
      : '';
    panel.innerHTML = `<h3>Current: ${info.title}</h3><p>${info.desc}${eventsHtml}</p>`;
  }
}

function fireChatEvent(event) {
  const transitions = {
    'none':   { create: 'active' },
    'active': { output: 'active', idle: 'idle', 'exit-ok': 'done', 'exit-err': 'error', delete: 'deleted' },
    'idle':   { output: 'active', 'exit-ok': 'done', 'exit-err': 'error', delete: 'deleted' },
    'done':   { resume: 'active' },
    'error':  { resume: 'active' },
  };
  const next = transitions[chatState]?.[event];
  if (next) {
    // flash the transition
    const svg = document.getElementById('chat-svg');
    svg.querySelectorAll('.transition').forEach(t => t.classList.remove('highlighted'));
    setChatState(next);
  }
}

function resetChatSim() {
  chatState = 'none';
  const svg = document.getElementById('chat-svg');
  svg.querySelectorAll('.state').forEach(s => s.classList.remove('current', 'highlighted'));
  svg.querySelectorAll('.transition').forEach(t => t.classList.remove('highlighted'));
  document.getElementById('chat-info').innerHTML = '<h3>Chat Lifecycle</h3><p>Click a state or use simulation buttons to walk through the machine.</p>';
}

// ========== Harness Simulation ==========
let harnessState = 'h-idle';
let toolsUsed = 0;

function setHarnessState(state) {
  harnessState = state;
  const svg = document.getElementById('harness-svg');
  svg.querySelectorAll('.state').forEach(s => {
    s.classList.remove('current');
    if (s.dataset.state === state) s.classList.add('current');
  });
  const info = stateInfo[state];
  if (info) {
    const panel = document.getElementById('harness-info');
    let eventsHtml = info.events.length
      ? '<br>' + info.events.map(e => `<span class="tag event">${e}</span>`).join(' ')
      : '';
    panel.innerHTML = `<h3>Current: ${info.title}</h3><p>${info.desc}${eventsHtml}<br><br>Tools used: <code>${toolsUsed}</code></p>`;
  }
}

function fireHarnessEvent(event) {
  const transitions = {
    'h-idle':     { thinking: 'h-thinking', writing: 'h-writing', 'tool-start': 'h-tool-use', stop: 'h-done' },
    'h-thinking': { writing: 'h-writing', 'tool-start': 'h-tool-use', waiting: 'h-waiting', stop: 'h-done' },
    'h-writing':  { thinking: 'h-thinking', 'tool-start': 'h-tool-use', waiting: 'h-waiting', stop: 'h-done' },
    'h-tool-use': { 'tool-end': 'h-writing', 'tool-start': 'h-tool-use', stop: 'h-done' },
    'h-waiting':  { thinking: 'h-thinking', writing: 'h-writing', 'tool-start': 'h-tool-use', stop: 'h-done' },
    'h-done':     {},
    'h-error':    {},
  };
  if (event === 'tool-start') toolsUsed++;
  const next = transitions[harnessState]?.[event];
  if (next) setHarnessState(next);
}

function resetHarnessSim() {
  harnessState = 'h-idle';
  toolsUsed = 0;
  const svg = document.getElementById('harness-svg');
  svg.querySelectorAll('.state').forEach(s => s.classList.remove('current', 'highlighted'));
  document.getElementById('harness-info').innerHTML = '<h3>Harness Tracker</h3><p>Use simulation buttons to step through harness states. Tracks per-chat AI agent activity.</p>';
}

// ========== PTY Simulation ==========
let ptyState = 'p-none';
let ptyBufKB = 0;

function setPtyState(state) {
  ptyState = state;
  const svg = document.getElementById('pty-svg');
  svg.querySelectorAll('.state').forEach(s => {
    s.classList.remove('current');
    if (s.dataset.state === state) s.classList.add('current');
  });
  // Update buffer display
  const runningText = svg.querySelector('[data-state="p-running"] text:last-child');
  if (runningText) runningText.textContent = `buf: ${ptyBufKB}KB`;

  const info = stateInfo[state];
  if (info) {
    const panel = document.getElementById('pty-info');
    panel.innerHTML = `<h3>Current: ${info.title}</h3><p>${info.desc}<br><br>Buffer: <code>${ptyBufKB}KB / 200KB</code></p>`;
  }
}

function firePtyEvent(event) {
  switch(event) {
    case 'create':
      if (ptyState === 'p-none') { ptyBufKB = 0; setPtyState('p-spawned'); }
      break;
    case 'output':
      if (ptyState === 'p-spawned' || ptyState === 'p-running') {
        ptyBufKB = Math.min(ptyBufKB + 30, 200);
        setPtyState('p-running');
      }
      break;
    case 'overflow':
      if (ptyState === 'p-running') {
        ptyBufKB = 220;
        setPtyState('p-overflow');
        setTimeout(() => { ptyBufKB = 100; setPtyState('p-running'); }, 800);
      }
      break;
    case 'write':
      if (ptyState === 'p-running' || ptyState === 'p-spawned') {
        // just visual feedback
        setPtyState(ptyState);
      }
      break;
    case 'exit':
      if (ptyState === 'p-running' || ptyState === 'p-spawned') setPtyState('p-exited');
      break;
    case 'seed':
      if (ptyState === 'p-spawned') { ptyBufKB = 50; setPtyState('p-running'); }
      break;
    case 'destroy':
      if (ptyState !== 'p-none' && ptyState !== 'p-destroyed') { ptyBufKB = 0; setPtyState('p-destroyed'); }
      break;
  }
}

function resetPtySim() {
  ptyState = 'p-none';
  ptyBufKB = 0;
  const svg = document.getElementById('pty-svg');
  svg.querySelectorAll('.state').forEach(s => s.classList.remove('current', 'highlighted'));
  document.getElementById('pty-info').innerHTML = '<h3>PTY Manager</h3><p>Use simulation buttons to step through PTY lifecycle.</p>';
}

// ========== Startup Flow Steps ==========
function activateStep(el) {
  // deactivate siblings
  const parent = el.parentElement;
  parent.querySelectorAll('.flow-step').forEach(s => s.classList.remove('active-step'));
  el.classList.add('active-step');

  // show detail in nearest info panel
  const view = el.closest('.view');
  const panel = view.querySelector('.info-panel');
  if (panel && el.dataset.detail) {
    const stepNum = el.querySelector('.step-num').textContent;
    const title = el.querySelector('h4').textContent;
    panel.innerHTML = `<h3>Step ${stepNum}: ${title}</h3><p>${el.dataset.detail}</p>`;
  }
}

// ========== Event Family Details ==========
function showEventFamily(family) {
  const panel = document.getElementById('events-info');
  const details = {
    terminal: `<h3>Terminal Events</h3>
      <p>Emitted by <code>ChatRegistry</code> and <code>PtyManager</code> during chat and PTY lifecycle changes.</p>
      <p style="margin-top:8px;">
        <strong>chat:created</strong> — new chat allocated<br>
        <strong>chat:resumed</strong> — existing chat restarted with new PTY<br>
        <strong>chat:deleted</strong> — chat and directory removed<br>
        <strong>chat:status</strong> — state transition (includes <code>from</code> and <code>to</code> fields)<br>
        <strong>pty:spawned</strong> — new PTY process created<br>
        <strong>pty:exit</strong> — PTY process terminated (includes <code>exitCode</code>)<br>
        <strong>pty:prompt-delivered</strong> — initial prompt written to PTY<br>
        <strong>schedule:triggered</strong> — cron/one-time schedule fired<br>
        <strong>schedule:completed</strong> — scheduled task finished
      </p>`,
    harness: `<h3>Harness Events</h3>
      <p>Two sources: <strong>CLI hooks</strong> (Claude only — PreToolUse/PostToolUse/Stop hooks call <code>chorale hook</code>) and <strong>Output parser</strong> (all CLIs — heuristic pattern matching on PTY output).</p>
      <p style="margin-top:8px;">
        <strong>harness:tool:start</strong> — tool execution began (includes tool name)<br>
        <strong>harness:tool:end</strong> — tool execution completed<br>
        <strong>harness:thinking</strong> — agent is reasoning (spinner detected)<br>
        <strong>harness:writing</strong> — agent is producing output<br>
        <strong>harness:waiting</strong> — agent waiting for input (prompt detected)<br>
        <strong>harness:stop</strong> — agent session complete (cost summary)<br>
        <strong>harness:status</strong> — unified state change from HarnessTracker
      </p>`,
    cli: `<h3>CLI Events</h3>
      <p>Emitted by <code>ApiServer</code> on every incoming agent request via the <code>chorale</code> CLI.</p>
      <p style="margin-top:8px;">
        <strong>cli:dispatch</strong> — agent spawned a child chat<br>
        <strong>cli:status</strong> — agent queried chat status<br>
        <strong>cli:schedule</strong> — schedule create/cancel/list/run<br>
        <strong>cli:report</strong> — agent sent message to parent PTY<br>
        <strong>cli:project</strong> — agent listed or opened a project<br>
        <strong>cli:hook</strong> — agent emitted a lifecycle hook event
      </p>`
  };
  panel.innerHTML = details[family] || '';
}

// ========== Data flow steps use activateStep ==========
document.querySelectorAll('#data-flow-steps .flow-step').forEach(el => {
  // already has onclick via activateStep
});
</script>

</body>
</html>
